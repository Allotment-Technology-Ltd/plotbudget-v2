#!/usr/bin/env node
// Parses a Next.js webpack bundle stats HTML report and enforces a KB size budget.
// Exits non-zero when the total client bundle exceeds the budget.
// Usage: node scripts/parse-webpack-stats.js --report <path-to-stats.html> --max-kb <number>
//
// The report is generated by ANALYZE=true next build (using @next/bundle-analyzer).
// The script reads the generated JSON embedded in the HTML (or a companion .json file).

const fs = require('fs');
const path = require('path');

const args = process.argv.slice(2);

function getArg(name) {
  const idx = args.indexOf(name);
  return idx !== -1 ? args[idx + 1] : null;
}

const reportArg = getArg('--report');
const maxKbArg = getArg('--max-kb');
const maxKb = maxKbArg ? parseInt(maxKbArg, 10) : (parseInt(process.env.BUNDLE_MAX_KB, 10) || 300);

if (!reportArg) {
  console.error('Usage: node scripts/parse-webpack-stats.js --report <path> --max-kb <number>');
  process.exit(1);
}

const reportPath = path.resolve(process.cwd(), reportArg);

if (!fs.existsSync(reportPath)) {
  console.error(`Report file not found: ${reportPath}`);
  console.error('Run `ANALYZE=true pnpm --filter=@repo/web build` first to generate bundle stats.');
  process.exit(1);
}

// @next/bundle-analyzer writes a JSON sidecar file alongside the HTML.
// Try <report>.json first, then fall back to extracting from the HTML.
const jsonPath = reportPath.replace(/\.html$/, '.json');
let stats = null;

if (fs.existsSync(jsonPath)) {
  try {
    stats = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
  } catch {
    // fall through to HTML parsing
  }
}

if (!stats) {
  // Extract JSON data embedded in the bundle-analyzer HTML report.
  const html = fs.readFileSync(reportPath, 'utf8');
  // The analyzer embeds the data as: window.chartData = {...};
  const match = html.match(/window\.chartData\s*=\s*(\{[\s\S]*?\});\s*<\/script>/);
  if (!match) {
    console.error(
      'Could not extract bundle data from report HTML.\n' +
        'Ensure the file was generated by @next/bundle-analyzer.'
    );
    process.exit(1);
  }
  try {
    stats = JSON.parse(match[1]);
  } catch (e) {
    console.error('Failed to parse embedded bundle JSON:', e.message);
    process.exit(1);
  }
}

// Sum up all module sizes (statSize = uncompressed bytes).
function sumStatSize(node) {
  if (typeof node.statSize === 'number') return node.statSize;
  if (Array.isArray(node.groups)) {
    return node.groups.reduce((acc, child) => acc + sumStatSize(child), 0);
  }
  return 0;
}

let totalBytes = 0;
if (Array.isArray(stats)) {
  totalBytes = stats.reduce((acc, chunk) => acc + sumStatSize(chunk), 0);
} else if (stats && typeof stats === 'object') {
  totalBytes = sumStatSize(stats);
}

const totalKb = Math.round(totalBytes / 1024);

console.log(`Bundle size: ${totalKb} KB (budget: ${maxKb} KB)`);

if (totalKb > maxKb) {
  console.error(
    `\n❌ Bundle size ${totalKb} KB exceeds budget of ${maxKb} KB.\n` +
      '   Identify and fix the largest modules:\n' +
      '   1. Run ANALYZE=true pnpm --filter=@repo/web build and open the report.\n' +
      '   2. Use next/dynamic() to code-split heavy components.\n' +
      '   3. Replace large libraries with lighter alternatives or import only submodules.\n' +
      '   4. Move server-only logic out of client components.'
  );
  process.exit(1);
}

console.log(`✅ Bundle size is within budget (${totalKb} KB ≤ ${maxKb} KB)`);
process.exit(0);
